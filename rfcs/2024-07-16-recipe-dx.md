# Recipe/Module DX that is human and LLM friendly

Goal: A JS/TS framework that looks reasonably familiar to someone used to modern
frameworks, but generates Common recipes and modules, that can be verified
against Common guardrails and run safely in the Common runtime.

This initial take lands somewhere in between exposing the underlying primitives
and mimicking existing frameworks. In particular the names might appear a little
odd at first, and are very much subject to future bikeshedding.

From here we can do future iterations to much more closely mimick existing
frameworks, though in many cases this might require a bit of code transformation
via TS plugins.

TBH, we might want some code transformation early on anyway, e.g. to extract
schema information from typescript types. For now we'll use overly verbose JSON
schema.

## Recipe definitions

### Signature

Recipes are defined as functions, that are passed to `recipe`. All "input" cells
are passed in as an object as the first parameter. All "output" cells, i.e.
meant to be used by other recipes are in the return value, again as an object.
Add doc strings (`/** ... */`) to add descriptions and possibly constraints that
are then added to the generated JSON schema for the recipe.

```ts
import { recipe } from "@commontools/common-recipes";

export default recipe(
  ({
    foo,
    bar,
  }: {
    /** A foo-lish entity */
    foo: string;
    /** A bar-ish value */
    bar: number;
  }) => {
    return {
      /** A baz-illed combination of foo and bar */
      baz: { foo, bar },
    };
  }
);
```

By default, input cells are read-only, but you can wrap parts of them with
`Mutable<>` or `Writeonly<>`:

```ts
import { recipe, Mutable, Writeonly } from "@commontools/common-recipes";

export default recipe(
  ({
    foo,
    bar,
  }: {
    /** A foo-lish entity */
    foo: { value: Mutable<string> };
    /** A bar-ish value */
    bar: { value: Writeonly<number> };
  }) => {
    /** Normalized foo */
    foo.value = apply({ foo }, ({ foo }) => foo.trim());

    /** Length of foo */
    bar.value = apply({ foo }, ({ foo }) => foo.length);

    return {
      /** A baz-illed combination of foo and bar */
      baz: { foo, bar },
    };
  }
);
```

The two `apply` calls are inline modules, which we'll discuss below.

Note that you can't directly read or modify cells in the scope of the recipe
function itself: Those must be done in module calls. This is because the recipe
function just creates the graph, _before_ it runs, before even any of the values
are known.

Note that we can still return a `Writeonly` value. The annotations just control
what the recipe is allowed to do, it doesn't mark the cell as imported by others
as write only.

Above, we had to add `value` properties so that we can set value (`foo = ...`
wouldn't have changed the original `foo`). Instead we can also call `.set()` on
the cell:

```ts
import {
  recipe,
  MutableRefernce,
  WriteonlyReference,
} from "@commontools/common-recipes";

export default recipe(
  ({
    foo,
    bar,
  }: {
    /** A foo-lish entity */
    foo: MutableReference<string>;
    /** A bar-ish value */
    bar: WriteonlyReference<number>;
  }) => {
    foo.set(apply({ foo }, ({ foo }) => foo.trim()));
    bar.set(apply({ foo }, ({ foo }) => foo.length));
    return {
      /** A baz-illed combination of foo and bar */
      baz: { foo, bar },
    };
  }
);
```

Alternatively, this would have worked as well:

```ts
import { recipe, Mutable, Writeonly } from "@commontools/common-recipes";

export default recipe(
  (params: {
    /** A foo-lish entity */
    foo: Mutable<string>;
    /** A bar-ish value */
    bar: Writeonly<number>;
  }) => {
    params.foo = apply({ foo }, ({ foo }) => foo.trim());
    params.bar = apply({ foo }, ({ foo }) => foo.length);
    return {
      /** A baz-illed combination of foo and bar */
      baz: params,
    };
  }
);
```

There is also `Opaque<>` that is neither read or write and only allows passing
through a reference:

```ts
import { recipe, Opaque } from "@commontools/common-recipes";

export default recipe(
  ({
    foo,
  }: {
    /** A foo-lish entity */
    foo: Opaque<string>;
  }) => {
    return {
      /** A baz-il titled foo */
      baz: { title: foo },
    };
  }
);
```

Input cells can be optional, at which point they need a default value provided
by `Optional<type, default value>`:

```ts
import { recipe, Optional } from "@commontools/common-recipes";

export default recipe(
  ({
    foo,
  }: {
    /** A foo-lish entity */
    foo: Optional<string, "default title">;
  }) => {
    return {
      /** A baz-il titled foo */
      baz: { title: foo },
    };
  }
);
```

`Mutable<Optional<...>>` is also allowed.

## Code modules

We already saw two simple inline modules above. Modules can be definied
analogously to recipes, except that instead

- of using `recipe`, it's `lift`
- of being run once to create a graph (with the corresponding modules from
  inline modules), they are run on every invocation.
- of receiving cells that can't be read or written to directly, they get a proxy
  representing the values of the cells

```ts
import { lift, recipe } from "@commontools/common-recipes";

export const trim = lift(
  ({ str }: { /** String to be trimmed */ str: string }) => ({
    trimmed: str.trim(),
  })
);

export default recipe(
  ({
    foo,
  }: {
    /** A foo-lish entity */
    foo: string;
  }) => {
    const { trimmed } = trim({ str: foo });
    return {
      /** A baz-il titled foo */
      baz: { title: trimmed },
    };
  }
);
```

Once the recipe is instantied `trim` is called every time the cell associated
with `foo` changes.

Note the destructuring to `{ trimmed }` in the recipe function: This creates a
cell reference to the value of trimmed, which can then be used below.

`lift` returns a node factory, that recipe functions use to build graphs. And so
does `recipe`, by the way: From the perspective of a recipe author code modules
and recipes modules are then same.

Note: We could also have written this with anonymous parameters and a single
return value:

```ts
...
export const trim = lift((str: string) => str.trim());
...
return { baz: { title: trim(foo) } };
```

TBD, what's a better style. For recipes naming cells at least at the top level
is mandatory (TBD: Or we could define a default cell name?).

And we already saw the inline version with `apply`, where the single return
value case might make more sense. `apply` is internally calling `lift` with the
second parameter and then immediately calling the returned function with the
first parameter, thus creating a node. `apply` called with an array as first
parameter will call the function with multiple parameters, non-arrays are used
as first and only parameter (cells that are arrays count as a non-array
parameter, though we might want to support the `...cell` operation to expand
such an array if this is ever useful).

`Mutable` and `Writeonly` work the same way. Then the function to be lifted
isn't pure anymore, so proceed with caution. It might be good practice to lift
the impure part into the recipe, as in the first example above: `foo.value =
trim({ str: foo.value })`, unless not otherwise possible.

`ReadonlyReference`, `WriteonlyReference` and `MutableReference` (reference to a
mutable value, not a mutable reference itself, so -TBD- maybe rename?) are also
available and likewise useful when setting values.

And `Opaque` is very often useful to reduce taint. `OpaqueExcept<...>` yields
opaque references, except for some properties (TBD: Build out with examples and
how to distinguish mutable, writeonly, etc.).

### Streams

A common case, where we do want to write into passed cells are event handlers:

```ts
export const incrementCounter = liftHandler(
  (_event, { counter }: { counter: MutableReference<number> }) =>
    counter.set(counter.get() + 1)
);
```

(TBD: We might want to flip the default for handlers and make cells mutable by
default and use `readonly` or `Readonly<>` to mark some read only)

These are called once on each event. They are not called when any of the other
passed cells change. Their return value, if any, is treated as another event.

Inline handlers are defined with `handler`:

```ts
export default recipe(...
...
const myHandler = handler({ counter }, (_, params) => params.counter++);
```

All the modifiers for recipes apply as well for `lift`, `apply`, `liftHandler`
and `handler`.

In both cases, `myHandler` can be bound to where a writeable stream is expected.

Alternatively to the handler helpers, we could have written them with `lift` or
`apply` using `CommonEvent<...>` types and binding the streams accordingly.

## Cells are nested

It was a bit implicit above, but cells can be treated as nested in both the
recipe definition as well as in modules.

TODO: Finish

## UI

Putting it all together with the new `html` ... TODO
